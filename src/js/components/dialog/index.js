/**
 * --------------------------------------------------------------------------
 * Licensed under MIT (https://github.com/quark-dev/Phonon-Framework/blob/master/LICENSE)
 * --------------------------------------------------------------------------
 */
import { generateId } from '../../core/utils'
import Event from '../../core/events'
import { dispatchElementEvent } from '../../core/events/dispatch'

const Dialog = (() => {
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */

  const NAME = 'dialog'
  const VERSION = '2.0.0'
  const BACKDROP_SELECTOR = 'dialog-backdrop'
  const DEFAULT_PROPERTIES = {
    element: null,
    title: null,
    message: null,
    cancelable: true
  }

  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  class Dialog {
    constructor(options = {}) {
      this.options = Object.assign(DEFAULT_PROPERTIES, options)

      if (typeof this.options.element === 'string') {
        this.options.element = document.querySelector(this.options.element)
      }

      this.dynamicElement = this.options.element === null

      this.template = '' +
      '<div class="dialog-inner" role="document">' +
        '<div class="dialog-content">' +
          '<div class="dialog-header">' +
            '<h5 class="dialog-title"></h5>' +
          '</div>' +
          '<div class="dialog-body">' +
            '<p></p>' +
          '</div>' +
          '<div class="dialog-footer">' +
            '<button type="button" class="btn btn-primary" data-dismiss="dialog">Ok</button>' +
          '</div>' +
        '</div>' +
      '</div>'

      this.id = generateId()

      if (this.dynamicElement) {
        this.build()
      }

      this.clickCancelableHandler = event => this.onCancelDialog(event)
    }

    static get version() {
      return `${NAME}.${VERSION}`
    }

    build() {
      const div = document.createElement('div')
      div.classList.add('dialog')

      div.setAttribute('data-id', this.id)
      div.setAttribute('tabindex', '-1')
      div.setAttribute('role', 'dialog')

      div.innerHTML = this.template

      // title
      if (this.options.title !== null) {
        div.querySelector('.dialog-title').innerHTML = this.options.title
      }

      // message
      if (this.options.message !== null) {
        div.querySelector('.dialog-body').firstChild.innerHTML = this.options.message
      }

      this.options.element = div

      document.body.appendChild(this.options.element)
    }

    // private
    buildBackdrop() {
      const backdrop = document.createElement('div')
      backdrop.setAttribute('data-id', this.id)
      backdrop.classList.add(BACKDROP_SELECTOR)

      document.body.appendChild(backdrop)
    }

    getBackdrop() {
      return document.querySelector(`.${BACKDROP_SELECTOR}[data-id="${this.id}"]`)
    }

    center() {
      const computedStyle = window.getComputedStyle(this.options.element)
      // const width = computedStyle.width.slice(0, computedStyle.width.length - 2)
      const height = computedStyle.height.slice(0, computedStyle.height.length - 2)

      const top = (window.innerHeight / 2) - (height / 2)
      this.options.element.style.top = `${top}px`
    }

    show() {
      if (this.options.element === null) {
        // build and insert a new DOM element
        this.build()
      }

      if (this.options.element.classList.contains('show')) {
        console.error(`${NAME}. The dialog is already visible.`)
        return
      }

      // add a timeout so that the CSS animation works
      setTimeout(() => {
        this.callEvent(Event.SHOW)
        this.buildBackdrop()
        this.options.element.classList.add('show')
        this.center()

        // attach event
        this.attachEvents()
      }, 1)
    }

    onCancelDialog(event) {
      if (event.type === 'keyup' && event.keyCode !== 27 && event.keyCode !== 13) {
        return
      }

      const backdrop = this.getBackdrop()

      // remove events
      backdrop.removeEventListener(Event.START, this.clickCancelableHandler)
      document.removeEventListener('keyup', this.clickCancelableHandler)

      // hide the dialog
      this.hide()
    }

    onHidden() {
      const backdrop = this.getBackdrop()
      document.body.removeChild(backdrop)

      this.options.element.classList.remove('hide')

      backdrop.removeEventListener(Event.TRANSITION_END, event => this.onHidden(event), false)

      // remove autogenerated dialogs, see: #199
      if (this.dynamicElement) {
        document.body.removeChild(this.options.element)
        this.options.element = null
      }
    }

    hide() {
      if (!this.options.element.classList.contains('show')) {
        console.error(`${NAME}. The dialog is not visible.`)
        return
      }

      this.detachEvents()
      
      this.options.element.classList.add('hide')
      this.options.element.classList.remove('show')

      const backdrop = this.getBackdrop()
      backdrop.addEventListener(Event.TRANSITION_END, event => this.onHidden(event), false)
      backdrop.classList.add('fadeout')
    }

    attachEvents () {
      const dismissButtons = this.options.element.querySelectorAll('[data-dismiss]')
      if (dismissButtons) {
        dismissButtons.forEach(button => {
          button.addEventListener('click', this.clickCancelableHandler)
        })
      }

      // add events if the dialog is cancelable
      // which means the user can hide the dialog
      // by pressing the ESC key or click outside the backdrop
      if (this.options.cancelable) {
        const backdrop = this.getBackdrop()

        // add events
        backdrop.addEventListener(Event.START, this.clickCancelableHandler)
        document.addEventListener('keyup', this.clickCancelableHandler)
      }
    }

    detachEvents () {
      const dismissButtons = this.options.element.querySelectorAll('[data-dismiss]')
      if (dismissButtons) {
        dismissButtons.forEach(button => {
          button.removeEventListener('click', this.clickCancelableHandler)
        })
      }

      if (this.options.cancelable) {
        const backdrop = this.getBackdrop()
        backdrop.removeEventListener(Event.START, this.clickCancelableHandler)        
        document.removeEventListener('keyup', this.clickCancelableHandler)        
      }
    }

    callEvent(eventName) {
      const eventNameAlias = `on${eventName.charAt(0).toUpperCase()}${eventName.slice(1)}`

      // object event
      if (typeof this.options[eventName] === 'function') {
        this.options[eventName].apply(this)
      }

      if (typeof this.options[eventNameAlias] === 'function') {
        this.options[eventNameAlias].apply(this)
      }

      // dom event
      dispatchElementEvent(this.options.element, eventName, NAME)
    }

    static _DOMInterface(options) {
      return new Dialog(options)
    }
  }

  return Dialog
})()

export default Dialog
